<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="data:image/svg+xml,
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'>
<text y='.9em' font-size='90'>üïπÔ∏è</text>
</svg>">

  <meta charset="UTF-8" />
  <title>Week 09 ‚Äì Space Shooter Pt. 1 | Game Dev With Rob</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- RaRa theme CSS -->
  <link rel="stylesheet" href="assets/rara-games-devtools.css" />

  <!-- Prism.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-tomorrow.min.css">
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>
</head>
<body>

  <!-- Top site header -->
  <header class="site-header">
    <div class="header-inner">
      <div class="brand">
        <div class="brand-main">
          <div class="brand-dot"></div>
          <span>Game Dev With Rob üïπÔ∏è</span>
        </div>
        <div class="brand-course">
          <!-- MODULE CODE + TITLE HERE -->
          GDD422 ‚Äì Prototypes &amp; Programming Principles
        </div>
      </div>
    </div>
  </header>

  <main class="lecture-page">

    <!-- LECTURE HEADER (now static, not sticky) -->
    <header class="lecture-header">
      <h1><!-- LECTURE TITLE HERE -->Space Shooter Pt. 1</h1>

      <div class="lecture-meta-line">
        <!-- MODULE TITLE + WEEK INFO HERE -->
        GDD422 ‚Äì Week 09
      </div>

      <div class="tags">
        <!-- TAGS / TOPICS HERE -->
        <span class="tag">C#</span>
        <span class="tag">Lab</span>
        <span class="tag">2D Arcade</span>
      </div>

      <p class="lecture-aim">
        <!-- AIM TEXT HERE -->
        Aim: Start building a fun and frantic arcade-style shmup in Unity C#.
      </p>
    </header>

    <hr />

 <!-- GAMMA EMBED BLOCK -->
<section class="lecture-section" id="slides">
  <h2>Lecture Slides</h2>

  <!-- FULLSCREEN TOGGLE BUTTON -->
  <button id="fullscreenBtn" class="resource-pill" style="margin-bottom: 1rem;">
    ‚õ∂ Fullscreen Slides
  </button>

  <!-- EMBED WRAPPER -->
  <div class="gamma-embed">
    <div class="gamma-embed-inner">

      <iframe
        id="gammaFrame"
        src="https://gamma.app/embed/e842znwz41ztvgw"
        loading="lazy"
        allowfullscreen
        allow="fullscreen"
        style="border: 0;"
      ></iframe>

    </div>
  </div>
</section>

<!-- FULLSCREEN JS -->
<script>
  const iframe = document.getElementById('gammaFrame');
  const btn = document.getElementById('fullscreenBtn');

  btn.addEventListener('click', () => {
    if (!document.fullscreenElement) {
      iframe.requestFullscreen().then(() => {
        btn.textContent = "‚õ∂ Exit Fullscreen";
      }).catch(err => {
        console.error("Fullscreen error: ", err);
      });
    } else {
      document.exitFullscreen().then(() => {
        btn.textContent = "‚õ∂ Fullscreen Slides";
      });
    }
  });

  // Ensure the button resets if user exits with ESC or browser UI
  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement) {
      btn.textContent = "‚õ∂ Fullscreen Slides";
    }
  });
</script>



    <hr />

    <!-- APPENDICES / CODE EXAMPLES -->
    <section class="lecture-section appendix-section" id="appendices">
      <h2>Appendices / Code Examples</h2>

      <!-- CODE BLOCK 1 -->
      <article class="code-example" id="code-block-1">
        <div class="code-header">
          <div class="code-title">Code Block 1 ‚Äì <!-- Short description here -->Player Movement</div>
          <div class="code-ref">Appendix #01</div>
        </div>
<details>
<summary>üí° Hints (click to expand)</summary>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class Player : MonoBehaviour
{
    // How fast the player moves in units per second
    public float moveSpeed = 10f;

    // Input values read each frame
    private float moveX;
    private float moveY;

    private void Update()
    {
        // 1. Read horizontal and vertical input (-1 to +1)
        moveX = Input.GetAxis("Horizontal");
        moveY = Input.GetAxis("Vertical");

        // 2. Turn input into a movement vector
        //    Multiply by moveSpeed and deltaTime for smooth, frame-independent motion
        Vector2 movement = new Vector2(moveX, moveY) * moveSpeed * Time.deltaTime;

        // 3. Add movement onto the current position
        Vector3 newPos = transform.position + (Vector3)movement;

        // 4. Apply the new position back to the Transform
        transform.position = newPos;
    }
}

        </code></pre>
  </details>

        <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          Make sure you‚Äôre adding the movement onto the current position and using <code>deltaTime</code>, otherwise the player will move inconsistently or far too quickly.
        </blockquote>
      </article>
  
      <!-- CODE BLOCK 2 -->
      <article class="code-example" id="code-block-2">
        <div class="code-header">
          <div class="code-title">Code Block 2 ‚Äì <!-- Short description here -->Screen Boundaries.</div>
          <div class="code-ref">Appendix #02</div>
        </div>
<details>
<summary>üí° Hints (click to expand)</summary>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class Player : MonoBehaviour
{
    // Movement speed in units per second
    public float moveSpeed = 10f;

    // Input values read each frame
    private float moveX;
    private float moveY;

    // Padding from the edges of the screen
    public float paddingLeft   = 0.5f;
    public float paddingRight  = 0.5f;
    public float paddingTop    = 0.5f;
    public float paddingBottom = 0.5f;

    // Calculated world-space bounds for the player
    private float xMin;
    private float xMax;
    private float yMin;
    private float yMax;

    private void Start()
    {
        // Calculate the world-space edges of the camera view once at the start
        Camera cam = Camera.main;
        if (cam == null)
        {
            Debug.LogWarning("Player: No MainCamera found. Please tag your camera as 'MainCamera'.");
            return;
        }

        // Left and right edges in world space
        Vector3 leftEdge  = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, 0f));
        Vector3 rightEdge = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, 0f));

        // Bottom and top edges in world space
        Vector3 bottomEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, 0f));
        Vector3 topEdge    = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, 0f));

        // Apply padding so the ship doesn't touch the exact screen edge
        xMin = leftEdge.x   + paddingLeft;
        xMax = rightEdge.x  - paddingRight;
        yMin = bottomEdge.y + paddingBottom;
        yMax = topEdge.y    - paddingTop;
    }

    private void Update()
    {
        // 1. Read horizontal and vertical input (-1 to +1)
        moveX = Input.GetAxis("Horizontal");
        moveY = Input.GetAxis("Vertical");

        // 2. Turn input into a movement vector
        Vector2 movement = new Vector2(moveX, moveY) * moveSpeed * Time.deltaTime;

        // 3. Calculate the tentative new position
        Vector3 newPos = transform.position + (Vector3)movement;

        // 4. Clamp X and Y so the player stays within the screen bounds
        float clampedX = Mathf.Clamp(newPos.x, xMin, xMax);
        float clampedY = Mathf.Clamp(newPos.y, yMin, yMax);

        // 5. Apply the clamped position (we keep the original Z)
        transform.position = new Vector3(clampedX, clampedY, newPos.z);
    }
}

        </code></pre>
</details>

        <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If clamping doesn‚Äôt work, check that the camera is tagged ‚ÄúMainCamera‚Äù and that you calculated min/max using <code>ViewportToWorldPoint</code> with the correct coordinates.
        </blockquote>
      </article>
  

      <!-- CODE BLOCK 3 -->
      <article class="code-example" id="code-block-3">
        <div class="code-header">
          <div class="code-title">Code Block 3 ‚Äì <!-- Short description here -->Preliminary Laser Firing</div>
          <div class="code-ref">Appendix #03</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>Player.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class Player : MonoBehaviour
{
    // ----- Movement -----
    public float moveSpeed = 10f;

    private float moveX;
    private float moveY;

    public float paddingLeft   = 0.5f;
    public float paddingRight  = 0.5f;
    public float paddingTop    = 0.5f;
    public float paddingBottom = 0.5f;

    private float xMin;
    private float xMax;
    private float yMin;
    private float yMax;

    // ----- Firing (single shot) -----
    // Prefab of the laser to spawn
    public GameObject laserPrefab;

    // How fast the laser travels upwards
    public float laserSpeed = 15f;

    private void Start()
    {
        // Setup screen bounds for clamping
        Camera cam = Camera.main;
        if (cam == null)
        {
            Debug.LogWarning("Player: No MainCamera found.");
            return;
        }

        Vector3 leftEdge   = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, 0f));
        Vector3 rightEdge  = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, 0f));
        Vector3 bottomEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, 0f));
        Vector3 topEdge    = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, 0f));

        xMin = leftEdge.x   + paddingLeft;
        xMax = rightEdge.x  - paddingRight;
        yMin = bottomEdge.y + paddingBottom;
        yMax = topEdge.y    - paddingTop;
    }

    private void Update()
    {
        HandleMovement();
        HandleSingleShotFire();
    }

    private void HandleMovement()
    {
        // Read input each frame
        moveX = Input.GetAxis("Horizontal");
        moveY = Input.GetAxis("Vertical");

        // Convert input to movement
        Vector2 movement = new Vector2(moveX, moveY) * moveSpeed * Time.deltaTime;
        Vector3 newPos = transform.position + (Vector3)movement;

        // Clamp within screen bounds
        float clampedX = Mathf.Clamp(newPos.x, xMin, xMax);
        float clampedY = Mathf.Clamp(newPos.y, yMin, yMax);

        transform.position = new Vector3(clampedX, clampedY, newPos.z);
    }

    private void HandleSingleShotFire()
    {
        // Fire one laser when SPACE is pressed down
        if (Input.GetKeyDown(KeyCode.Space))
        {
            if (laserPrefab == null)
            {
                Debug.LogWarning("Player: No laserPrefab assigned.");
                return;
            }

            // Spawn a new laser at the player's position
            GameObject laserInstance = Instantiate(
                laserPrefab,
                transform.position,
                Quaternion.identity
            );

            // Give the laser an upward velocity
            Rigidbody2D rb = laserInstance.GetComponent<Rigidbody2D>();
            if (rb != null)
            {
                rb.velocity = new Vector2(0f, laserSpeed);
            }
        }
    }
}


        </code></pre>
          <code>LaserProjectile.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;

public class LaserProjectile : MonoBehaviour
{
    // When this object is no longer visible by any camera,
    // Unity calls this automatically.
    private void OnBecameInvisible()
    {
        // Clean up the projectile so it doesn't live forever off-screen
        Destroy(gameObject);
    }
}

          
        </code></pre>
</details>

        <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If your laser doesn‚Äôt move or even appear, double-check that the prefab has a <code>Rigidbody2D</code> with zero gravity and that you assigned the prefab reference in the Inspector.
        </blockquote>
      </article>

      <!-- CODE BLOCK 4 -->
      <article class="code-example" id="code-block-4">
        <div class="code-header">
          <div class="code-title">Code Block 4 ‚Äì <!-- Short description here -->Continuous Firing With a Coroutine</div>
          <div class="code-ref">Appendix #04</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>Player.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;
using System.Collections;  // Needed for IEnumerator and coroutines

public class Player : MonoBehaviour
{
    // ----- Movement -----
    public float moveSpeed = 10f;

    private float moveX;
    private float moveY;

    public float paddingLeft   = 0.5f;
    public float paddingRight  = 0.5f;
    public float paddingTop    = 0.5f;
    public float paddingBottom = 0.5f;

    private float xMin;
    private float xMax;
    private float yMin;
    private float yMax;

    // ----- Firing (continuous) -----
    public GameObject laserPrefab;   // Laser to spawn
    public float laserSpeed = 15f;   // How fast lasers travel upwards
    public float firingInterval = 0.2f; // Delay between shots while firing

    // Reference to the running coroutine (if any)
    private Coroutine firingCoroutine;

    private void Start()
    {
        // Setup screen bounds
        Camera cam = Camera.main;
        if (cam == null)
        {
            Debug.LogWarning("Player: No MainCamera found.");
            return;
        }

        Vector3 leftEdge   = cam.ViewportToWorldPoint(new Vector3(0f, 0.5f, 0f));
        Vector3 rightEdge  = cam.ViewportToWorldPoint(new Vector3(1f, 0.5f, 0f));
        Vector3 bottomEdge = cam.ViewportToWorldPoint(new Vector3(0.5f, 0f, 0f));
        Vector3 topEdge    = cam.ViewportToWorldPoint(new Vector3(0.5f, 1f, 0f));

        xMin = leftEdge.x   + paddingLeft;
        xMax = rightEdge.x  - paddingRight;
        yMin = bottomEdge.y + paddingBottom;
        yMax = topEdge.y    - paddingTop;
    }

    private void Update()
    {
        HandleMovement();
        HandleContinuousFire();
    }

    private void HandleMovement()
    {
        // Read input
        moveX = Input.GetAxis("Horizontal");
        moveY = Input.GetAxis("Vertical");

        // Apply movement
        Vector2 movement = new Vector2(moveX, moveY) * moveSpeed * Time.deltaTime;
        Vector3 newPos = transform.position + (Vector3)movement;

        // Clamp within bounds
        float clampedX = Mathf.Clamp(newPos.x, xMin, xMax);
        float clampedY = Mathf.Clamp(newPos.y, yMin, yMax);

        transform.position = new Vector3(clampedX, clampedY, newPos.z);
    }

    private void HandleContinuousFire()
    {
        // Start firing when Fire1 is pressed
        if (Input.GetButtonDown("Fire1"))
        {
            if (firingCoroutine == null)
            {
                firingCoroutine = StartCoroutine(FireContinuously());
            }
        }

        // Stop firing when Fire1 is released
        if (Input.GetButtonUp("Fire1"))
        {
            if (firingCoroutine != null)
            {
                StopCoroutine(firingCoroutine);
                firingCoroutine = null;
            }
        }
    }

    private IEnumerator FireContinuously()
    {
        // Loop forever until stopped from outside
        while (true)
        {
            if (laserPrefab != null)
            {
                // Spawn a laser at the player's position
                GameObject laserInstance = Instantiate(
                    laserPrefab,
                    transform.position,
                    Quaternion.identity
                );

                // Give the laser upward velocity
                Rigidbody2D rb = laserInstance.GetComponent<Rigidbody2D>();
                if (rb != null)
                {
                    rb.velocity = new Vector2(0f, laserSpeed);
                }
            }
            else
            {
                Debug.LogWarning("Player: No laserPrefab assigned.");
            }

            // Wait for the firing interval before spawning the next shot
            yield return new WaitForSeconds(firingInterval);
        }
    }
}

          </code></pre>
</details>
          <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If the firing speed seems wrong or never stops, make sure you're only starting the coroutine once and stopping it correctly when the button is released.
        </blockquote>
      </article>

      <!-- CODE BLOCK 5 -->
      <article class="code-example" id="code-block-5">
        <div class="code-header">
          <div class="code-title">Code Block 5 ‚Äì <!-- Short description here -->Enemy Waypoints Setup & Debug</div>
          <div class="code-ref">Appendix #05</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>EnemyPathing.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;
using System.Collections.Generic; // Needed for List<>

public class EnemyPathing : MonoBehaviour
{
    // Parent object that holds the waypoint children (e.g. "Path_01")
    public Transform pathRoot;

    // List of waypoints the enemy will eventually follow
    public List<Transform> waypoints = new List<Transform>();

    private void Start()
    {
        // Safety check ‚Äì make sure a path has been assigned
        if (pathRoot == null)
        {
            Debug.LogWarning("EnemyPathing: No pathRoot assigned on " + gameObject.name);
            return;
        }

        // Populate the waypoints list from all children of pathRoot
        foreach (Transform child in pathRoot)
        {
            // Each child under pathRoot is treated as one waypoint
            waypoints.Add(child);
        }

        // Log each waypoint so we can check the order in the Console
        for (int i = 0; i < waypoints.Count; i++)
        {
            Transform wp = waypoints[i];
            Debug.Log(
                $"Waypoint {i} -> {wp.name} at position {wp.position}",
                this
            );
        }
    }
}

        </code></pre>
</details>

          <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If no waypoints print to the Console, confirm that the <code>pathRoot</code> object is assigned and that the waypoint transforms are children of it in the correct order.
        </blockquote>
      </article>

      <!-- CODE BLOCK 6 -->
      <article class="code-example" id="code-block-6">
        <div class="code-header">
          <div class="code-title">Code Block 6 ‚Äì <!-- Short description here -->Moving the Enemy With MoveTowards</div>
          <div class="code-ref">Appendix #06</div>
        </div>
        <details>
<summary>üí° Hints (click to expand)</summary>
<code>EnemyPathing.cs</code>
        <pre class="language-csharp"><code class="language-csharp">
using UnityEngine;
using System.Collections.Generic;

public class EnemyPathing : MonoBehaviour
{
    // Parent object that holds the waypoint children
    public Transform pathRoot;

    // Ordered list of waypoints to follow
    public List<Transform> waypoints = new List<Transform>();

    // Movement speed along the path
    public float moveSpeed = 3f;

    // Index of the current waypoint we are moving towards
    private int currentIndex = 0;

    // How close is "close enough" to consider a waypoint reached
    public float arriveThreshold = 0.1f;

    private void Start()
    {
        if (pathRoot == null)
        {
            Debug.LogWarning("EnemyPathing: No pathRoot assigned on " + gameObject.name);
            return;
        }

        // Fill the waypoints list from children of pathRoot
        foreach (Transform child in pathRoot)
        {
            waypoints.Add(child);
        }

        if (waypoints.Count == 0)
        {
            Debug.LogWarning("EnemyPathing: No waypoint children found under " + pathRoot.name);
            return;
        }

        // Start the enemy at the first waypoint position
        transform.position = waypoints[0].position;

        // Optional: log the waypoint order once, like in Appendix 05
        for (int i = 0; i < waypoints.Count; i++)
        {
            Transform wp = waypoints[i];
            Debug.Log($"Waypoint {i} -> {wp.name} at position {wp.position}", this);
        }
    }

    private void Update()
    {
        // Only move if we have waypoints to follow
        if (waypoints.Count == 0) return;

        FollowPath();
    }

    private void FollowPath()
    {
        // If we've already passed the last waypoint, destroy the enemy
        if (currentIndex >= waypoints.Count)
        {
            Destroy(gameObject);
            return;
        }

        // Get the current target waypoint
        Transform targetWaypoint = waypoints[currentIndex];

        // Move towards the target waypoint at a steady speed
        transform.position = Vector2.MoveTowards(
            transform.position,
            targetWaypoint.position,
            moveSpeed * Time.deltaTime
        );

        // Check how far we are from the target
        float distanceToTarget = Vector2.Distance(transform.position, targetWaypoint.position);

        // If close enough, move on to the next waypoint
        if (distanceToTarget < arriveThreshold)
        {
            currentIndex++;

            // If that was the last waypoint, the object will be cleaned up next frame
        }
    }
}

        </code></pre>
</details>
          <blockquote>
          <!-- NOTES ABOUT THIS CODE BLOCK -->
          If the enemy jumps or stops early, check that its starting position is set to the first waypoint and that the distance threshold allows it to reliably ‚Äúarrive‚Äù before advancing.
        </blockquote>
      </article>
          

    </section>

    <!-- DOWNLOADS -->
    <section class="lecture-section">
      <h2>Downloads</h2>
      <div class="resource-links">
        <!-- Update links/paths as appropriate -->
        <a class="resource-pill" href="https://github.com/robblofield/GDD422---Prototypes-and-Programming-Principles/tree/main/labs">
          üß™ Lab Files
        </a>
        <a class="resource-pill" href="https://github.com/robblofield/Unity-Project-Startup-Files">
          üì¶ Unity Project Startup Files
        </a>
      </div>
    </section>

  </main>

</body>
</html>

